---
layout: article
title:  "「VIDEO」 关键帧提取概述"
date:   2019-08-08 11:06:40 +0800
key: keyframe-survey-20190808
aside:
  toc: true
sidebar:
  nav: NDVR
category: [AI, video, key_frame]
---
<span id='head'></span>  
>视频相比图像来说信息更加丰富，但是一个序列里冗余信息太多，如何无监督的提取关键帧的信息对于很多任务都是至关重要的；    
相关资源：[关键帧提取资源汇总](/ai/video/key_frame/2019/06/12/foundation.html)、[图片相似度度量概述](/image_process/2019/06/25/image-similarities-survey.html)     

<!--more-->  
`key frame extraction` · `bag of keyframes` · `key frame detection`    

# 1 动机
1. **通用任务**：视频中大部分 clip 都不包含所做的运动信息（静止），如果把这些 clip 也放入网络训练，会对网络的训练起到一个反向的作用；**排除错误的 clip 的干扰（跟错）**`啥是跟错`{:.warning}；    
1. **视频检索**：存在数据量大、 维度高的特点，在检索过程中需要消耗大量的内存与搜索时间；关键帧提取是重要的预处理步骤；       
1. **视频摘要**：     

# 2 基于视频信息
[什么是I帧,P帧,B帧](https://blog.csdn.net/abcjennifer/article/details/6577934)     
视频压缩中，每帧代表一幅静止的图像；而在实际压缩时，会采取各种算法减少数据的容量，其中 IPB 就是最常见的；      

**I 帧**表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）；    
**P 帧**表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）；     
**B 帧**是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面；B帧压缩率高，但是解码时 CPU 会比较累；    

IPB 帧和我们所说的关键帧提取是不同的概念，生成的方式也不同，我们提取关键帧做视频特征提取，不能采用IPB帧的方式`为啥`{:.warning}；    

# 3 基于帧
[图片检索](/ai/cv/retrieval/2019/08/20/survey.html)；     

## 3.1 帧差法
**背景**：视频序列具有连续性的特点；如果场景内没有运动目标，则连续帧的变化很微弱，如果存在运动目标，则连续的帧和帧之间会有明显地变化；    
**流程**：相邻帧做差分运算，不同帧对应的像素点相减的到灰度差，当差值的绝对值之和超过一定阈值时，即可判断为有运动目标，从而提取关键帧；     
**特点**：原理简单，计算量小；  

`diff = cv.absdiff(frame,lastFrame)`      

**颜色直方图**可以看做是帧间差分法的一种，只不过用的是颜色直方图之间的差值，而非颜色编码之间的差值；    

```c++
gray = cv.cvtColor(frame,cv.COLOR_BGR2GRAY)# 提取灰度图像
hist = cv.calcHist([gray],[0],None,[256],[0,256])
diff = cv.absdiff(hist,lastHist)
```

基于帧间差分的提取关键帧的方法：    
1. 使用差分强度的顺序，对所有帧按照平均差分强度进行排序，选择平均帧间差分强度最高的若干张图片作为视频的关键帧；     
1. 使用平均帧间差分强度高于阈值的帧作为视频的关键帧；[AllenAnthony/Key-Frame](https://github.com/AllenAnthony/Key-Frame)     
1. 选择局部最大值,这种方法的提取结果在丰富度上表现更好一些，提取结果均匀分散在视频中；[CSDN/随煜而安](https://blog.csdn.net/u011583927/article/details/84842915)             

*也可应用于提取到运动目标：适用于目标运动较为缓慢的场景；当运动较快时，由于目标在相邻帧图像上的位置相差较大，两帧图像相减后并不能得到完整的运动目标，因此，人们在两帧差分法的基础上提出了三帧差分法；另外，针对运动目标检测，还有[背景减弱法和光流场法](https://blog.csdn.net/zhang1308299607/article/details/80081553)*    
*背景差分法：是当前运动目标检测技术中应用较为广泛的一类方法，它的基本思想和帧间差分法相类似，都是利用不同图像的差分运算提取目标区域；不过与帧间差分法不同的是，背景差分法不是将当前帧图像与相邻帧图像相减，而是将当前帧图像与一个不断更新的背景模型相减，在差分图像中提取运动目标；*     


## 3.2 聚类
对于视频中的各个图片，定义图片之间的相似度（如采用颜色直方图之间的差值）`跟谁做差`{:.warning}，然后用聚类算法，聚类的中心即为关键帧；     
聚类算法中，需要预定一个阈值来控制聚类的密度；在聚类过程中也可以加入约束条件，如每个聚类中的图像帧数目不应该太少或太多，每个聚类的质心不应该相似，也就是这些聚类质心的距离要大，还可以采用模糊聚类方法实现关键帧的提取；      
[中国科学院大学-关键帧提取课件](https://wenku.baidu.com/view/598512156bec0975f565e24d.html)     

## 3.3 深度特征
传统方法存在的问题：大多数的方案对镜头每帧进行[相似性的度量](/image_process/2019/06/25/image-similarities-survey.html)，并与某个固定的阈值进行比较来选出关键帧，然而该阈值确实难以确定，并且难以适合每个镜头；    

流程：取镜头中帧的平均值，然后取与均值最接近的帧作为关键帧，由此实现了自适应的关键帧提取；     


# 4 基于序列特征
## 3.1 LSTM
使用 LSTM 处理视频，为每一帧打一个分数，取分值较高的为关键帧；   


-------------------  
[End](#head)
{:.warning}  


# 附录
## A 参考资料

## B 扩展知识
1. 视频编码
[关键帧，帧间和视频压缩](https://www.jianshu.com/p/6c90f0513084)、[视频编解码器](https://zh.wikipedia.org/wiki/%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8)、[视频编码与视频格式的区别和联系](https://www.cnblogs.com/yinxiangpei/articles/3501800.html)  

封装格式及其对应的编码格式：    
AVI：MPEG-2，DIVX，XVID，AC-1，H.264;   
WMV：WMV，AC-1;    
RM、RMVB：RV， RM;   
MOV：MPEG-2，XVID，H.264;   
TS/PS：MPEG-2，H.264，MPEG-4;    
